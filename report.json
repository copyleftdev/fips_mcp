{"stats":{"totalMutantsCount":28,"killedCount":14,"notCoveredCount":0,"escapedCount":14,"errorCount":0,"skippedCount":0,"timeOutCount":0,"msi":0.5,"mutationCodeCoverage":0,"coveredCodeMsi":0},"escaped":[{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5/time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":70},"diff":"--- Original\n+++ New\n@@ -67,7 +67,7 @@\n \t\treturn err\n \tcase \u003c-ctx.Done():\n \t\t// Context was cancelled, shutdown the server\n-\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5/time.Second)\n \t\tdefer cancel()\n \t\treturn a.Shutdown(shutdownCtx)\n \t}\n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.0\" with checksum feca59e368a09d6e7540617c58b4d036\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\t_ = fmt.Errorf\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":26},"diff":"--- Original\n+++ New\n@@ -23,7 +23,7 @@\n // New creates a new application instance\n func New(cfg *config.Config) (*App, error) {\n \tif cfg == nil {\n-\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n+\t\t_ = fmt.Errorf\n \t}\n \n \tr := http.NewServeMux()\n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.2\" with checksum b08059eb905fc85346452330c4ad829d\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); true \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":51},"diff":"--- Original\n+++ New\n@@ -48,7 +48,7 @@\n \tserverErr := make(chan error, 1)\n \tgo func() {\n \t\tif a.config.TLSEnabled {\n-\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n+\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); true \u0026\u0026 err != http.ErrServerClosed {\n \t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n \t\t\t\treturn\n \t\t\t}\n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.8\" with checksum 4cf7bd02749f0e5d5bf6e4a814d5c615\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); true \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":56},"diff":"--- Original\n+++ New\n@@ -53,7 +53,7 @@\n \t\t\t\treturn\n \t\t\t}\n \t\t} else {\n-\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n+\t\t\tif err := a.server.ListenAndServe(); true \u0026\u0026 err != http.ErrServerClosed {\n \t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n \t\t\t\treturn\n \t\t\t}\n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.10\" with checksum fb8efffb75f010aa963d89f446f2fb35\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 0)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":48},"diff":"--- Original\n+++ New\n@@ -45,7 +45,7 @@\n func (a *App) Start(ctx context.Context) error {\n \tlog.Printf(\"Starting server on %s\", a.server.Addr)\n \n-\tserverErr := make(chan error, 1)\n+\tserverErr := make(chan error, 0)\n \tgo func() {\n \t\tif a.config.TLSEnabled {\n \t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.12\" with checksum 3eee7b5a36280f41e2c81c9f068d64ca\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 4*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":70},"diff":"--- Original\n+++ New\n@@ -67,7 +67,7 @@\n \t\treturn err\n \tcase \u003c-ctx.Done():\n \t\t// Context was cancelled, shutdown the server\n-\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 4*time.Second)\n \t\tdefer cancel()\n \t\treturn a.Shutdown(shutdownCtx)\n \t}\n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.13\" with checksum efa6fd0c609ccabb850faaec493eb52a\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 2)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":48},"diff":"--- Original\n+++ New\n@@ -45,7 +45,7 @@\n func (a *App) Start(ctx context.Context) error {\n \tlog.Printf(\"Starting server on %s\", a.server.Addr)\n \n-\tserverErr := make(chan error, 1)\n+\tserverErr := make(chan error, 2)\n \tgo func() {\n \t\tif a.config.TLSEnabled {\n \t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.14\" with checksum a3ce8162d806ea0d007ff9b129535c65\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 6*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":70},"diff":"--- Original\n+++ New\n@@ -67,7 +67,7 @@\n \t\treturn err\n \tcase \u003c-ctx.Done():\n \t\t// Context was cancelled, shutdown the server\n-\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 6*time.Second)\n \t\tdefer cancel()\n \t\treturn a.Shutdown(shutdownCtx)\n \t}\n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.15\" with checksum b60f9079c481ee7b26d51b3bc3b7baf2\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\t_ = r.HandleFunc\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":30},"diff":"--- Original\n+++ New\n@@ -27,7 +27,7 @@\n \t}\n \n \tr := http.NewServeMux()\n-\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n+\t_ = r.HandleFunc\n \tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n \n \tsrv := \u0026http.Server{\n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.16\" with checksum e0681cd60620bbb4eb859413c865bd65\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\t_ = r.HandleFunc\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":31},"diff":"--- Original\n+++ New\n@@ -28,7 +28,7 @@\n \n \tr := http.NewServeMux()\n \tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n-\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n+\t_ = r.HandleFunc\n \n \tsrv := \u0026http.Server{\n \t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.17\" with checksum ba85a44930c4421f6f48d5166f50d88a\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\t_, _ = log.Printf, a.server.Addr\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":46},"diff":"--- Original\n+++ New\n@@ -43,7 +43,7 @@\n \n // Start starts the application\n func (a *App) Start(ctx context.Context) error {\n-\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n+\t_, _ = log.Printf, a.server.Addr\n \n \tserverErr := make(chan error, 1)\n \tgo func() {\n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.18\" with checksum be07ad5656e99cedd7c2d8ac9de89967\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\t_ = log.Println\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":78},"diff":"--- Original\n+++ New\n@@ -75,7 +75,7 @@\n \n // Shutdown gracefully shuts down the application\n func (a *App) Shutdown(ctx context.Context) error {\n-\tlog.Println(\"Shutting down server...\")\n+\t_ = log.Println\n \treturn a.server.Shutdown(ctx)\n }\n \n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.19\" with checksum 02f293b9fb5dfdc2f847280bde3fc279\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_, _ = w.WriteHeader, http.StatusOK\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":90},"diff":"--- Original\n+++ New\n@@ -87,7 +87,7 @@\n \t}\n \n \tw.Header().Set(\"Content-Type\", \"application/json\")\n-\tw.WriteHeader(http.StatusOK)\n+\t_, _ = w.WriteHeader, http.StatusOK\n \tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n }\n \n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.21\" with checksum 6280f8622eb13e93451f0f23be5a7e04\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_, _ = w.WriteHeader, http.StatusOK\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":102},"diff":"--- Original\n+++ New\n@@ -99,6 +99,6 @@\n \t}\n \n \tw.Header().Set(\"Content-Type\", \"application/json\")\n-\tw.WriteHeader(http.StatusOK)\n+\t_, _ = w.WriteHeader, http.StatusOK\n \tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n }\n","processOutput":"FAIL \"/tmp/go-mutesting-2367713998/internal/app/app.go.25\" with checksum 1043de67e2a9c5110b4a710c57dffc51\n"}],"timeouted":null,"killed":[{"mutator":{"mutatorName":"branch/else","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\t_, _, _, _, _, _, _, _ = err, a.server.ListenAndServe, err, err, http.ErrServerClosed, serverErr, fmt.Errorf, err\n\t\t}\n\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":56},"diff":"--- Original\n+++ New\n@@ -53,11 +53,9 @@\n \t\t\t\treturn\n \t\t\t}\n \t\t} else {\n-\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n-\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n-\t\t\t\treturn\n-\t\t\t}\n+\t\t\t_, _, _, _, _, _, _, _ = err, a.server.ListenAndServe, err, err, http.ErrServerClosed, serverErr, fmt.Errorf, err\n \t\t}\n+\n \t\tserverErr \u003c- nil\n \t}()\n \n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.1\" with checksum 0db976efd7b22fd0b84f83fa4ca5d802\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\t_, _, _, _, _, _, _, _, _, _ = err, a.server.ListenAndServeTLS, a.config.CertFile, a.config.KeyFile, err, err, http.ErrServerClosed, serverErr, fmt.Errorf, err\n\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":51},"diff":"--- Original\n+++ New\n@@ -48,10 +48,8 @@\n \tserverErr := make(chan error, 1)\n \tgo func() {\n \t\tif a.config.TLSEnabled {\n-\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n-\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n-\t\t\t\treturn\n-\t\t\t}\n+\t\t\t_, _, _, _, _, _, _, _, _, _ = err, a.server.ListenAndServeTLS, a.config.CertFile, a.config.KeyFile, err, err, http.ErrServerClosed, serverErr, fmt.Errorf, err\n+\n \t\t} else {\n \t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n \t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.3\" with checksum 34fc816b07409a00a337bfd98bc8f278\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\t_, _, _ = serverErr, fmt.Errorf, err\n\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":52},"diff":"--- Original\n+++ New\n@@ -49,8 +49,8 @@\n \tgo func() {\n \t\tif a.config.TLSEnabled {\n \t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n-\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n-\t\t\t\treturn\n+\t\t\t\t_, _, _ = serverErr, fmt.Errorf, err\n+\n \t\t\t}\n \t\t} else {\n \t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.4\" with checksum 00d22caecdf743fcb3c7a91e8f0b6899\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\t_, _, _ = serverErr, fmt.Errorf, err\n\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":57},"diff":"--- Original\n+++ New\n@@ -54,8 +54,8 @@\n \t\t\t}\n \t\t} else {\n \t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n-\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n-\t\t\t\treturn\n+\t\t\t\t_, _, _ = serverErr, fmt.Errorf, err\n+\n \t\t\t}\n \t\t}\n \t\tserverErr \u003c- nil\n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.5\" with checksum 77f6d0507599cb7d75b2d72c79c6283a\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\t_, _, _ = http.Error, w, http.StatusMethodNotAllowed\n\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":85},"diff":"--- Original\n+++ New\n@@ -82,8 +82,8 @@\n // HealthCheckHandler handles health check requests\n func HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n \tif r.Method != http.MethodGet {\n-\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n-\t\treturn\n+\t\t_, _, _ = http.Error, w, http.StatusMethodNotAllowed\n+\n \t}\n \n \tw.Header().Set(\"Content-Type\", \"application/json\")\n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.6\" with checksum 909063e488991f9ca3b686e3cb3b6af4\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\t_, _, _ = http.Error, w, http.StatusMethodNotAllowed\n\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":97},"diff":"--- Original\n+++ New\n@@ -94,8 +94,8 @@\n // ReadinessCheckHandler handles readiness check requests\n func ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n \tif r.Method != http.MethodGet {\n-\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n-\t\treturn\n+\t\t_, _, _ = http.Error, w, http.StatusMethodNotAllowed\n+\n \t}\n \n \tw.Header().Set(\"Content-Type\", \"application/json\")\n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.7\" with checksum 600de2ac840276609b23a93c6a673000\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 true {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":51},"diff":"--- Original\n+++ New\n@@ -48,7 +48,7 @@\n \tserverErr := make(chan error, 1)\n \tgo func() {\n \t\tif a.config.TLSEnabled {\n-\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n+\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 true {\n \t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n \t\t\t\treturn\n \t\t\t}\n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.9\" with checksum c3182ca9a569cf9914832c3aadb86b99\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 true {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":56},"diff":"--- Original\n+++ New\n@@ -53,7 +53,7 @@\n \t\t\t\treturn\n \t\t\t}\n \t\t} else {\n-\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n+\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 true {\n \t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n \t\t\t\treturn\n \t\t\t}\n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.11\" with checksum 9f41b980c2d56cf7a5e5be5992b90704\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":89},"diff":"--- Original\n+++ New\n@@ -86,7 +86,6 @@\n \t\treturn\n \t}\n \n-\tw.Header().Set(\"Content-Type\", \"application/json\")\n \tw.WriteHeader(http.StatusOK)\n \tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n }\n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.20\" with checksum 06ce14eb9d743d0f05adfe7e53320b52\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\t_, _ = fmt.Fprintf, w\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":91},"diff":"--- Original\n+++ New\n@@ -88,7 +88,7 @@\n \n \tw.Header().Set(\"Content-Type\", \"application/json\")\n \tw.WriteHeader(http.StatusOK)\n-\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n+\t_, _ = fmt.Fprintf, w\n }\n \n // ReadinessCheckHandler handles readiness check requests\n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.22\" with checksum fd54910cda41e82e503fd13563ea470c\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\t_, _, _ = http.Error, w, http.StatusMethodNotAllowed\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":85},"diff":"--- Original\n+++ New\n@@ -82,7 +82,7 @@\n // HealthCheckHandler handles health check requests\n func HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n \tif r.Method != http.MethodGet {\n-\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t_, _, _ = http.Error, w, http.StatusMethodNotAllowed\n \t\treturn\n \t}\n \n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.23\" with checksum b96829d974ecdf0ab010df1f0059384e\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":101},"diff":"--- Original\n+++ New\n@@ -98,7 +98,6 @@\n \t\treturn\n \t}\n \n-\tw.Header().Set(\"Content-Type\", \"application/json\")\n \tw.WriteHeader(http.StatusOK)\n \tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n }\n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.24\" with checksum 2c9b777c8a7db02222ca0a035579f09b\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\t_, _ = fmt.Fprintf, w\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":103},"diff":"--- Original\n+++ New\n@@ -100,5 +100,5 @@\n \n \tw.Header().Set(\"Content-Type\", \"application/json\")\n \tw.WriteHeader(http.StatusOK)\n-\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n+\t_, _ = fmt.Fprintf, w\n }\n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.26\" with checksum a1ae4354ab735c70ffc31d72f99acf5f\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","mutatedSourceCode":"// Copyright 2025 copyleftdev. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage app\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/copyleftdev/fips-mcp/internal/config\"\n)\n\n// App represents the main application\ntype App struct {\n\tconfig *config.Config\n\tserver *http.Server\n}\n\n// New creates a new application instance\nfunc New(cfg *config.Config) (*App, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"config cannot be nil\")\n\t}\n\n\tr := http.NewServeMux()\n\tr.HandleFunc(\"/healthz\", HealthCheckHandler)\n\tr.HandleFunc(\"/readyz\", ReadinessCheckHandler)\n\n\tsrv := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", cfg.Host, cfg.Port),\n\t\tHandler: r,\n\t}\n\n\treturn \u0026App{\n\t\tconfig: cfg,\n\t\tserver: srv,\n\t}, nil\n}\n\n// Start starts the application\nfunc (a *App) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting server on %s\", a.server.Addr)\n\n\tserverErr := make(chan error, 1)\n\tgo func() {\n\t\tif a.config.TLSEnabled {\n\t\t\tif err := a.server.ListenAndServeTLS(a.config.CertFile, a.config.KeyFile); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTPS server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := a.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\t\tserverErr \u003c- fmt.Errorf(\"HTTP server error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tserverErr \u003c- nil\n\t}()\n\n\t// Wait for either server error or context cancellation\n\tselect {\n\tcase err := \u003c-serverErr:\n\t\treturn err\n\tcase \u003c-ctx.Done():\n\t\t// Context was cancelled, shutdown the server\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\treturn a.Shutdown(shutdownCtx)\n\t}\n}\n\n// Shutdown gracefully shuts down the application\nfunc (a *App) Shutdown(ctx context.Context) error {\n\tlog.Println(\"Shutting down server...\")\n\treturn a.server.Shutdown(ctx)\n}\n\n// HealthCheckHandler handles health check requests\nfunc HealthCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ok\"}`)\n}\n\n// ReadinessCheckHandler handles readiness check requests\nfunc ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet {\n\t\t_, _, _ = http.Error, w, http.StatusMethodNotAllowed\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, `{\"status\":\"ready\"}`)\n}\n","originalFilePath":"internal/app/app.go","originalStartLine":97},"diff":"--- Original\n+++ New\n@@ -94,7 +94,7 @@\n // ReadinessCheckHandler handles readiness check requests\n func ReadinessCheckHandler(w http.ResponseWriter, r *http.Request) {\n \tif r.Method != http.MethodGet {\n-\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t_, _, _ = http.Error, w, http.StatusMethodNotAllowed\n \t\treturn\n \t}\n \n","processOutput":"PASS \"/tmp/go-mutesting-2367713998/internal/app/app.go.27\" with checksum 3cc01c3ba31830cd28ef4e82406bfa1c\n"}],"errored":null}